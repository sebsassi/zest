<!doctype html>
<html class="no-js" lang="en" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Library reference" href="reference.html" /><link rel="prev" title="Theoretical background" href="introduction.html" />

    <!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>Anatomy of zest - zest 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">zest 0.1.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">zest 0.1.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Theoretical background</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Anatomy of zest</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Library reference</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="_sources/anatomy.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="anatomy-of-zest">
<h1>Anatomy of zest<a class="headerlink" href="#anatomy-of-zest" title="Link to this heading">¶</a></h1>
<p>This section of the documentation outlines the core features of zest, and their usage, motivating
some of the architectural decisions and giving guidance on best practices. Knowledge of the
contents of the section on theoretical background is assumed in this section.</p>
<section id="layouts-complex-multidimensional-indexing">
<h2>Layouts – complex multidimensional indexing<a class="headerlink" href="#layouts-complex-multidimensional-indexing" title="Link to this heading">¶</a></h2>
<p>In dealing with spherical harmonic and Zernike expansions, one runs into nontrivial indexing
schemes. Spherical harmonics are indexed by the pair of integers <span class="math notranslate nohighlight">\((l,m)\)</span>, for which the
condition <span class="math notranslate nohighlight">\(|m|\leq l\)</span> applies. With some cutoff <span class="math notranslate nohighlight">\(l\leq L\)</span>, these index are organized
in a triangle in the plane. The Zernike functions, on the other hand, are indexed by the triple
<span class="math notranslate nohighlight">\((n,l,m)\)</span>, with not only the condition <span class="math notranslate nohighlight">\(|m|\leq l\leq n\)</span>, but also that <span class="math notranslate nohighlight">\((n - l)/2\)</span>
must be an integer, which forces <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(l\)</span> to have the same parity. These indices are
organized in a tetrahedron with holes in it where <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(l\)</span> do not satisfy the parity
condition.</p>
<p>Mapping these multidimensional index schemes onto a one-dimensional buffer is a challenging
endeavor. The simplest solution would be to use a conventional multidimensional array to store the
elements corresponding to the indices, but this means that there will be elements in the buffer
that are never accessed. For example, the index triple <span class="math notranslate nohighlight">\((1,2,3)\)</span> doesn’t correspond to any
Zernike function, and therefore there is never need to access the corresponding element. For
spherical harmonics, half of the elements in the buffer would never be accessed, and for Zernike
functions up 83% of the elements would never be accessed. This is both wasteful in terms of memory
usage, and bad for cache utilization.</p>
<p>Fortunately, it is relatively straightforward to create more compact schemes. for storing elements.
For example, spherical harmonic coefficients can be stored sequentially by mapping the index pair
<span class="math notranslate nohighlight">\((l,m)\)</span> to the one-dimensional index <span class="math notranslate nohighlight">\(i = l(l + 1) + m\)</span> without any wasted memory.
An alternative is to map pairs <span class="math notranslate nohighlight">\(\{|m|,-|m|\}\)</span> onto the indices <span class="math notranslate nohighlight">\(l(l + 1)/2 + |m|\)</span>. This
wastes a small amount of memory because <span class="math notranslate nohighlight">\(m = 0\)</span> maps to both elements of the pair, but has
some desirable properties for iteration over the buffer.</p>
<p>To deal with differing indexing schemes in a unified and flexible manner, zest uses a system of
<em>layouts</em>. A 2D layout, for example, is a type with the structure</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">SomeLayout</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">index_type</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">size_type</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">IndexRange</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">SubLayout</span><span class="p">;</span><span class="w"> </span><span class="c1">// optional</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">LayoutTag</span><span class="w"> </span><span class="n">layout_tag</span><span class="p">;</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">order</span><span class="p">);</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="nf">idx</span><span class="p">(</span><span class="n">index_type</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">index_type</span><span class="w"> </span><span class="n">m</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">size</span></code> gives the total number of elements in an index set as determined by the
parameter <code class="docutils literal notranslate"><span class="pre">order</span></code>. The exact definition of <code class="docutils literal notranslate"><span class="pre">order</span></code> depends on the layout. For example, for
spherical harmonic coefficients cut off at some degree <span class="math notranslate nohighlight">\(L\)</span> such that <span class="math notranslate nohighlight">\(|m|\leq l\leq L\)</span>,
<code class="docutils literal notranslate"><span class="pre">order</span></code> is by convention equal to <span class="math notranslate nohighlight">\(L + 1\)</span>. The case for Zernike functions is analogous. For
the layout of a basic 1D array, <code class="docutils literal notranslate"><span class="pre">order</span></code> would just be the size. The convention is such that
<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">0</span></code> always corresponds to an empty layout.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">idx</span></code> gives the index in the one-dimensional buffer corresponding to the pair
<span class="math notranslate nohighlight">\((l,m)\)</span>, in this case. For example, it could return <span class="math notranslate nohighlight">\(l(l + 1) + m\)</span> for a spherical
harmonic layout.</p>
<p>The constant <code class="docutils literal notranslate"><span class="pre">layout_tag</span></code> is used by zest to identify what type of index geometry the layout is
intended to represent.</p>
<p>The member type <code class="docutils literal notranslate"><span class="pre">SubLayout</span></code> is a layout of one dimension lower to facilitate accessing
lower-dimensional slices of the index set. For example, for a layout for spherical harmonic
coefficients, it would be a 1D layout for to the row of <span class="math notranslate nohighlight">\(m\)</span> values that correspond to a
single <span class="math notranslate nohighlight">\(l\)</span>.</p>
<p>Finally, the member type <code class="docutils literal notranslate"><span class="pre">IndexRange</span></code> leads to another concept in zest, the concept of <em>index
ranges</em>. Because of potential nontrivial restrictions on indices—e.g., that <span class="math notranslate nohighlight">\(n\)</span> and
<span class="math notranslate nohighlight">\(l\)</span> must have the same parity when dealing with Zernike functions—iterating through index
sets by hand is error prone. Consider, for example, iterating <span class="math notranslate nohighlight">\(l\)</span> for Zernike functions</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Do things</span>
</pre></div>
</div>
<p>For someone used to writing C-style for-loops, it is easy to go through the motions and write
<code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">=</span> <span class="pre">0</span></code> instead of <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">%</span> <span class="pre">2</span></code>, or <code class="docutils literal notranslate"><span class="pre">++l</span></code> instead of <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">+=</span> <span class="pre">2</span></code>, either of which will lead to
hard to diagnose bugs. Furthermore, this way it is difficult to write generic code, which can
iterate both spherical harmonic and Zernike indices. Index ranges allow the use of range-based
for-loops instead</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SomeLayout</span><span class="o">::</span><span class="n">IndexRange</span><span class="w"> </span><span class="n">indices</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Do things</span>
</pre></div>
</div>
</section>
<section id="containers-and-views">
<h2>Containers and views<a class="headerlink" href="#containers-and-views" title="Link to this heading">¶</a></h2>
<p>For handling expansion coefficients and quadrature grids, zest presents a number of containers and
views. Containers are objects which own the underlying buffer they refer to, i.e., they are
responsible for allocation and deallocation of the buffer. Views are objects which do not own the
buffer they refer to; they simply give a <em>view</em> to a buffer owned by some other object.</p>
<p>The library comes with a number of containers for easy storage and manipulation of different types
of data. For storing spherical harmonic and Zernike expansions of real functions, there are the
classes <a class="reference internal" href="reference.html#_CPPv4I_6SHNorm_7SHPhase0EN4zest2st15RealSHExpansionE" title="zest::st::RealSHExpansion"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::RealSHExpansion</span></code></a> and <a class="reference internal" href="reference.html#_CPPv4I_11ZernikeNorm_N2st6SHNormE_N2st7SHPhaseE0EN4zest2zt20RealZernikeExpansionE" title="zest::zt::RealZernikeExpansion"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeExpansion</span></code></a>
respectively.</p>
<p>The template parameters of these containers primarily control the various normalization conventions.
The parameter <code class="docutils literal notranslate"><span class="pre">ElementType</span></code> is the type of elements in the underlying buffer. There are two main
choices here: if <code class="docutils literal notranslate"><span class="pre">ElementType</span></code> is a floating point type (e.g., <code class="docutils literal notranslate"><span class="pre">double</span></code>), this implies that the
elements are stored sequentially with <span class="math notranslate nohighlight">\(m\)</span> going from <span class="math notranslate nohighlight">\(-l\)</span> to <span class="math notranslate nohighlight">\(l\)</span>. On the other
hand, if <code class="docutils literal notranslate"><span class="pre">ElementType</span></code> is an array-like type of length two, e.g., <code class="docutils literal notranslate"><span class="pre">std::array&lt;double,</span> <span class="pre">2&gt;</span></code>, then
the elements are stored in pairs <span class="math notranslate nohighlight">\(\{|m|,-|m|\}\)</span> with <span class="math notranslate nohighlight">\(|m|\)</span> running from zero to
<span class="math notranslate nohighlight">\(l\)</span>. The latter option is the default and recommended option when dealing with the
quadrature-based transforms, but the former is mandatory for fitting an expansion to data.</p>
<p>For these classes, the library provides a number of convenient aliases for various common
combinations of normalization and phase conventions. For spherical harmonics these aliases are</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2st24RealSHExpansionAcousticsE" title="zest::st::RealSHExpansionAcoustics"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::RealSHExpansionAcoustics</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2st17RealSHExpansionQME" title="zest::st::RealSHExpansionQM"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::RealSHExpansionQM</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2st18RealSHExpansionGeoE" title="zest::st::RealSHExpansionGeo"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::RealSHExpansionGeo</span></code></a></p></li>
</ul>
<p>For Zernike functions there are corresponding aliases for the unnormalized radial functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2zt29RealZernikeExpansionAcousticsE" title="zest::zt::RealZernikeExpansionAcoustics"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeExpansionAcoustics</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2zt22RealZernikeExpansionQME" title="zest::zt::RealZernikeExpansionQM"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeExpansionQM</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2zt23RealZernikeExpansionGeoE" title="zest::zt::RealZernikeExpansionGeo"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeExpansionGeo</span></code></a></p></li>
</ul>
<p>and furthermore for the normalized radial Zernike polynomials:</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2zt35RealZernikeExpansionNormalAcousticsE" title="zest::zt::RealZernikeExpansionNormalAcoustics"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeExpansionNormalAcoustics</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2zt28RealZernikeExpansionNormalQME" title="zest::zt::RealZernikeExpansionNormalQM"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeExpansionNormalQM</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4N4zest2zt29RealZernikeExpansionNormalGeoE" title="zest::zt::RealZernikeExpansionNormalGeo"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeExpansionNormalGeo</span></code></a></p></li>
</ul>
<p>For storage of function values on Gauss–Legendre quadrature grids there are the classes
<a class="reference internal" href="reference.html#_CPPv4I00EN4zest2st13SphereGLQGridE" title="zest::st::SphereGLQGrid"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::SphereGLQGrid</span></code></a> and <a class="reference internal" href="reference.html#_CPPv4I00EN4zest2zt11BallGLQGridE" title="zest::zt::BallGLQGrid"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::BallGLQGrid</span></code></a> for the sphere and ball,
respectively. The <code class="docutils literal notranslate"><span class="pre">ElementType</span></code> parameter here is simply a floating point type. The parameter
<code class="docutils literal notranslate"><span class="pre">LayoutType</span></code>, in turn, describes how the multidimensional grid is laid out in memory. This is not
something a user of the library generally needs to worry about, because the default layout is the
layout that should be used for performing the transforms to expansion coefficients.</p>
<p>Mirroring the convention of the C++ standard library, views to buffers in zest are referred with
the word “span”. Each of the above containers has a corresponding view. Thus we have
<a class="reference internal" href="reference.html#_CPPv4I0_6SHNorm_7SHPhaseEN4zest2st10RealSHSpanE" title="zest::st::RealSHSpan"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::RealSHSpan</span></code></a> and <a class="reference internal" href="reference.html#_CPPv4I0_11ZernikeNorm_N2st6SHNormE_N2st7SHPhaseEEN4zest2zt15RealZernikeSpanE" title="zest::zt::RealZernikeSpan"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::RealZernikeSpan</span></code></a> with the corresponding
aliases for different normalization/phase conventions, and <a class="reference internal" href="reference.html#_CPPv4I00EN4zest2st17SphereGLQGridSpanE" title="zest::st::SphereGLQGridSpan"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">zest::st::SphereGLQGridSpan</span></code></a>
and <a class="reference internal" href="reference.html#_CPPv4I00EN4zest2zt15BallGLQGridSpanE" title="zest::zt::BallGLQGridSpan"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">zest::zt::BallGLQGridSpan</span></code></a> for the quadrature grids.</p>
<p>In additon, for completeness it is worth mentioning the <a class="reference internal" href="reference.html#_CPPv4I0_NSt6size_tEEN4zest6MDSpanE" title="zest::MDSpan"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">zest::MDSpan</span></code></a>, which is a
general multidimensional array view, and is the base of both <a class="reference internal" href="reference.html#_CPPv4I00EN4zest2st17SphereGLQGridSpanE" title="zest::st::SphereGLQGridSpan"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">zest::st::SphereGLQGridSpan</span></code></a>
and <a class="reference internal" href="reference.html#_CPPv4I00EN4zest2zt15BallGLQGridSpanE" title="zest::zt::BallGLQGridSpan"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">zest::zt::BallGLQGridSpan</span></code></a>. It is a poor man’s alternative to C++23’s <code class="docutils literal notranslate"><span class="pre">std::mdspan</span></code>,
replicating the part of its interface, which is necessary for this library.</p>
<p>Views are very useful, because they allow for more flexible storage of the expansions and grids.
For example, zest does not offer a container for storage of multiple spherical harmonic expansions,
and that is by design. If one needed to work with multiple spherical harmonic expansions at the
same time—a scenario which is very easy to imagine—they might be tempted to use something like
<code class="docutils literal notranslate"><span class="pre">std::vector</span></code> to store the expansions. But this involves multiple memory allocations, one for
each expansion, and spreads the expansions across memory, which is not cache friendly and could
negatively impact performance if the expansions are small.</p>
<p>Instead, what one should do is allocate one buffer of the expansion’s underlying type, which stores
all the expansions back to back in the same buffer, and then take views into that buffer to access
the different expansions. For example</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">ExpansionSpan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zest</span><span class="o">::</span><span class="n">st</span><span class="o">::</span><span class="n">RealSHExpansionQM</span><span class="p">;</span>

<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_expansions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">expansion_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExpansionSpan</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span>
<span class="n">expansion_buffer</span><span class="p">(</span><span class="n">num_expansions</span><span class="o">*</span><span class="n">expansion_size</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_expansions</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ExpansionSpan</span><span class="w"> </span><span class="nf">expansion</span><span class="p">(</span><span class="n">expansion_buffer</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">expansion_size</span><span class="p">,</span><span class="w"> </span><span class="n">order</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As is conventional in C++ libraries prior to C++23’s multidimensional subscript operator,
multidimensional views and containers can be indexed with the call operator <code class="docutils literal notranslate"><span class="pre">operator()</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="n">zest</span><span class="o">::</span><span class="n">st</span><span class="o">::</span><span class="n">RealSHExpansion</span><span class="w"> </span><span class="nf">expansion</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="n">expansion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">};</span>
<span class="n">expansion</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">};</span>
<span class="n">expansion</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5</span><span class="p">};</span>
<span class="n">expansion</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.25</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">};</span>
<span class="n">expansion</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.25</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.25</span><span class="p">};</span>
<span class="n">expansion</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.25</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.25</span><span class="p">};</span>
</pre></div>
</div>
<p>All multidimensional containers and views in this library allow for lower dimensional subviews to
be taken, which reproduce corresponding slices of the data. Specifically, the subscript operator
<code class="docutils literal notranslate"><span class="pre">operator[]</span></code> provides access to the lower dimensional subview</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">expansion</span><span class="p">.</span><span class="n">indices</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">expansion_l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expansion</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">expansion_m</span><span class="p">.</span><span class="n">indices</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">expansion_l</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>
<span class="w">        </span><span class="n">expansion_l</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example also demonstrates the use of the index ranges discussed in the previous subsection. In
fact, the above is the preferred way of iterating over an expansion, because it avoids the errors
that could be made in writing the constraints for the indices by hand.</p>
</section>
<section id="gauss-legendre-quadrature-transformers">
<h2>Gauss–Legendre quadrature transformers<a class="headerlink" href="#gauss-legendre-quadrature-transformers" title="Link to this heading">¶</a></h2>
<p>At the heart of zest are the Gauss–Legendre quadrature grid based transforms of spherical harmonic
and Zernike expansions. These transforms are implemented by the classes <a class="reference internal" href="reference.html#_CPPv4I_6SHNorm_7SHPhase0EN4zest2st14GLQTransformerE" title="zest::st::GLQTransformer"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::GLQTransformer</span></code></a>
and <a class="reference internal" href="reference.html#_CPPv4I_11ZernikeNorm_N2st6SHNormE_N2st7SHPhaseE0EN4zest2zt14GLQTransformerE" title="zest::zt::GLQTransformer"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::GLQTransformer</span></code></a> for spherical harmonic and Zernike transforms respectively.
The normalization and phase convention parameters are the same as those to the respective expansion
containers discussed above. To that end, both transformer classes have a set of aliases for some commond
combinations of normalization and phase conventions. These are</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2st23GLQTransformerAcousticsE" title="zest::st::GLQTransformerAcoustics"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::GLQTransformerAcoustics</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2st16GLQTransformerQME" title="zest::st::GLQTransformerQM"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::GLQTransformerQM</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2st17GLQTransformerGeoE" title="zest::st::GLQTransformerGeo"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::st::GLQTransformerGeo</span></code></a></p></li>
</ul>
<p>for the spherical harmonic transformer as well as</p>
<ul class="simple">
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2zt23GLQTransformerAcousticsE" title="zest::zt::GLQTransformerAcoustics"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::GLQTransformerAcoustics</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2zt16GLQTransformerQME" title="zest::zt::GLQTransformerQM"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::GLQTransformerQM</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2zt17GLQTransformerGeoE" title="zest::zt::GLQTransformerGeo"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::GLQTransformerGeo</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2zt29GLQTransformerNormalAcousticsE" title="zest::zt::GLQTransformerNormalAcoustics"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::GLQTransformerNormalAcoustics</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2zt22GLQTransformerNormalQME" title="zest::zt::GLQTransformerNormalQM"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::GLQTransformerNormalQM</span></code></a></p></li>
<li><p><a class="reference internal" href="reference.html#_CPPv4I0EN4zest2zt23GLQTransformerNormalGeoE" title="zest::zt::GLQTransformerNormalGeo"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">zest::zt::GLQTransformerNormalGeo</span></code></a></p></li>
</ul>
<p>for the Zernike transformer. The final parameter <code class="docutils literal notranslate"><span class="pre">GridLayoutType</span></code> in turn is the same as for the
corresponding grid containers.</p>
<p>It goes without saying that the transformer must have the same values for these template parameters
as the expansion and grid. This is one  of the ways zest protects consistency of conventions in
transformations.</p>
<p>The transformers come with two methods for performing transformations: <code class="docutils literal notranslate"><span class="pre">forward_transform</span></code> and
<code class="docutils literal notranslate"><span class="pre">backward_transform</span></code>. The forward transform transforms a grid to an expansion, and the backward
transform is the inverse, transforming an expansion to a grid. Both of these methods have two
primary overloads, one which takes both the input and output expansion/grid as arguments and
modifies the output</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">transformer</span><span class="p">.</span><span class="n">forward_transform</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">expansion</span><span class="p">);</span>
<span class="n">transformer</span><span class="p">.</span><span class="n">backward_transform</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="p">);</span>
</pre></div>
</div>
<p>and one which takes the input expansion/grid and returns the output container</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">expansion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformer</span><span class="p">.</span><span class="n">forward_transform</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">order</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">new_grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformer</span><span class="p">.</span><span class="n">backward_transform</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span><span class="w"> </span><span class="n">order</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the method takes the additional parameter <code class="docutils literal notranslate"><span class="pre">order</span></code>. In the case of the forward transform,
this parameter is the order of the expansion. Note that the grid has its own order parameter, which
is the maximum expansion order that can be taken with that grid. Therefore, the order of the output
expansion is <code class="docutils literal notranslate"><span class="pre">min(order,</span> <span class="pre">grid.order())</span></code>. On the other hand, in the backward transform, the
<code class="docutils literal notranslate"><span class="pre">order</span></code> parameter determines the point at which the summation of the expansion is truncated. The
order of <code class="docutils literal notranslate"><span class="pre">new_grid</span></code> will again be <code class="docutils literal notranslate"><span class="pre">min(order,</span> <span class="pre">expansion.order())</span></code>.</p>
</section>
<section id="rotations">
<h2>Rotations<a class="headerlink" href="#rotations" title="Link to this heading">¶</a></h2>
<p>For understanding this subsection discussing the implementation of rotations in zest, reading the
corresponding subsection in the theoretical background is highly recommended. In summary, zest
implements rotations for both spherical harmonic and Zernike expansions using the ZXZXZ algorithm.
This algorithm implements a rotation by Euler angles <span class="math notranslate nohighlight">\((\alpha,\beta,\gamma)\)</span> as a series of
rotations starting with a rotation about the z-axis by <span class="math notranslate nohighlight">\(\gamma\)</span>, followed by a 90 degree
rotation about the new x-axis, followed by a rotation about the new z-axis by <span class="math notranslate nohighlight">\(\beta\)</span>,
followed by a -90 degree rotation about the new x-axis, finally followed by a rotation about the
new z-axis by <span class="math notranslate nohighlight">\(\alpha\)</span>; hence ZXZXZ. This has the advantage that the general form of Wigner’s
D-matrices never needs to be evaluated. The x-axis rotations are expressible in terms of the
d-matrix for a 90 degree rotation, and can be precomputed once, On the other hand, the z-rotations
are just diagonal matrices of values <span class="math notranslate nohighlight">\(e^{im\theta_i}\)</span>, where <span class="math notranslate nohighlight">\(\theta_i\)</span> is one of
<span class="math notranslate nohighlight">\((\alpha,\beta,\gamma)\)</span>.</p>
<p>With this brief review of the essential facts, zest has a single class <a class="reference internal" href="reference.html#_CPPv4N4zest5RotorE" title="zest::Rotor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">zest::Rotor</span></code></a> for
performing the rotations, which has the method <code class="docutils literal notranslate"><span class="pre">rotate</span></code> for performing general rotations and
<code class="docutils literal notranslate"><span class="pre">polar_rotate</span></code> for the special case of rotations about the z-axis</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">zest</span><span class="o">::</span><span class="n">Rotor</span><span class="w"> </span><span class="nf">rotor</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="n">zest</span><span class="o">::</span><span class="n">WignerdPiHalfCollection</span><span class="w"> </span><span class="nf">wigner_d_pi2</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">euler_angles</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">};</span>
<span class="n">rotor</span><span class="p">.</span><span class="n">polar_rotate</span><span class="p">(</span>
<span class="w">    </span><span class="n">expansion</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">zest</span><span class="o">::</span><span class="n">RotationType</span><span class="o">::</span><span class="n">coordinate</span><span class="p">);</span>
<span class="n">rotor</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span>
<span class="w">    </span><span class="n">expansion</span><span class="p">,</span><span class="w"> </span><span class="n">wigner_d_pi2</span><span class="p">,</span><span class="w"> </span><span class="n">euler_angles</span><span class="p">,</span><span class="w"> </span><span class="n">zest</span><span class="o">::</span><span class="n">RotationType</span><span class="o">::</span><span class="n">coordinate</span><span class="p">);</span>
</pre></div>
</div>
<p>All rotations take as their last argument an enum of type <a class="reference internal" href="reference.html#_CPPv4N4zest12RotationTypeE" title="zest::RotationType"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">zest::RotationType</span></code></a>, which has
two values <a class="reference internal" href="reference.html#_CPPv4N4zest12RotationType6objectE" title="zest::RotationType::object"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">zest::RotationType::object</span></code></a> and <a class="reference internal" href="reference.html#_CPPv4N4zest12RotationType10coordinateE" title="zest::RotationType::coordinate"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">zest::RotationType::coordinate</span></code></a>.
These express whether the rotation represents a rotation of an object in space (active rotation) or
a rotation of the coordinate system (passive rotation). The polar rotation naturally takes as its
argument a single angle, whereas the general rotation takes three Euler angles, given as a standard
library array with three elements. Finally, the general rotation takes as its second argument an
object of type <a class="reference internal" href="reference.html#_CPPv4N4zest23WignerdPiHalfCollectionE" title="zest::WignerdPiHalfCollection"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">zest::WignerdPiHalfCollection</span></code></a>. This object contains the values of the
d-matrix for a 90 degree angle, i.e., <span class="math notranslate nohighlight">\(\pi/2\)</span>, up to some specified order.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="reference.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Library reference</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="introduction.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Theoretical background</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Sebastian Sassi
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Anatomy of zest</a><ul>
<li><a class="reference internal" href="#layouts-complex-multidimensional-indexing">Layouts – complex multidimensional indexing</a></li>
<li><a class="reference internal" href="#containers-and-views">Containers and views</a></li>
<li><a class="reference internal" href="#gauss-legendre-quadrature-transformers">Gauss–Legendre quadrature transformers</a></li>
<li><a class="reference internal" href="#rotations">Rotations</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=5fa4622c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>